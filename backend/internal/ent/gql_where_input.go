// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/gitwb-c/crm.saas/backend/internal/ent/chat"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/company"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/costumer"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/crmfield"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/deal"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/dealcrmfield"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/department"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/dropdownlist"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/employee"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/employeeauth"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/file"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/message"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/pipeline"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/predicate"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/queue"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/stage"
	"github.com/gitwb-c/crm.saas/backend/internal/ent/text"
	"github.com/google/uuid"
)

// ChatWhereInput represents a where input for filtering Chat queries.
type ChatWhereInput struct {
	Predicates []predicate.Chat  `json:"-"`
	Not        *ChatWhereInput   `json:"not,omitempty"`
	Or         []*ChatWhereInput `json:"or,omitempty"`
	And        []*ChatWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "accepted" field predicates.
	Accepted    *bool `json:"accepted,omitempty"`
	AcceptedNEQ *bool `json:"acceptedNEQ,omitempty"`

	// "locked" field predicates.
	Locked    *bool `json:"locked,omitempty"`
	LockedNEQ *bool `json:"lockedNEQ,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deal" edge predicates.
	HasDeal     *bool             `json:"hasDeal,omitempty"`
	HasDealWith []*DealWhereInput `json:"hasDealWith,omitempty"`

	// "employees" edge predicates.
	HasEmployees     *bool                 `json:"hasEmployees,omitempty"`
	HasEmployeesWith []*EmployeeWhereInput `json:"hasEmployeesWith,omitempty"`

	// "messages" edge predicates.
	HasMessages     *bool                `json:"hasMessages,omitempty"`
	HasMessagesWith []*MessageWhereInput `json:"hasMessagesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChatWhereInput) AddPredicates(predicates ...predicate.Chat) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChatWhereInput filter on the ChatQuery builder.
func (i *ChatWhereInput) Filter(q *ChatQuery) (*ChatQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChatWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChatWhereInput is returned in case the ChatWhereInput is empty.
var ErrEmptyChatWhereInput = errors.New("ent: empty predicate ChatWhereInput")

// P returns a predicate for filtering chats.
// An error is returned if the input is empty or invalid.
func (i *ChatWhereInput) P() (predicate.Chat, error) {
	var predicates []predicate.Chat
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, chat.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Chat, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, chat.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Chat, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, chat.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, chat.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, chat.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, chat.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, chat.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, chat.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, chat.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, chat.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, chat.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, chat.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, chat.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, chat.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, chat.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, chat.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, chat.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, chat.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, chat.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, chat.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, chat.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, chat.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, chat.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, chat.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Accepted != nil {
		predicates = append(predicates, chat.AcceptedEQ(*i.Accepted))
	}
	if i.AcceptedNEQ != nil {
		predicates = append(predicates, chat.AcceptedNEQ(*i.AcceptedNEQ))
	}
	if i.Locked != nil {
		predicates = append(predicates, chat.LockedEQ(*i.Locked))
	}
	if i.LockedNEQ != nil {
		predicates = append(predicates, chat.LockedNEQ(*i.LockedNEQ))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, chat.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, chat.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, chat.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, chat.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, chat.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, chat.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, chat.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, chat.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, chat.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, chat.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, chat.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, chat.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, chat.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, chat.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, chat.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, chat.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasDeal != nil {
		p := chat.HasDeal()
		if !*i.HasDeal {
			p = chat.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDealWith) > 0 {
		with := make([]predicate.Deal, 0, len(i.HasDealWith))
		for _, w := range i.HasDealWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDealWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, chat.HasDealWith(with...))
	}
	if i.HasEmployees != nil {
		p := chat.HasEmployees()
		if !*i.HasEmployees {
			p = chat.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeesWith))
		for _, w := range i.HasEmployeesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, chat.HasEmployeesWith(with...))
	}
	if i.HasMessages != nil {
		p := chat.HasMessages()
		if !*i.HasMessages {
			p = chat.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessagesWith) > 0 {
		with := make([]predicate.Message, 0, len(i.HasMessagesWith))
		for _, w := range i.HasMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMessagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, chat.HasMessagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChatWhereInput
	case 1:
		return predicates[0], nil
	default:
		return chat.And(predicates...), nil
	}
}

// CompanyWhereInput represents a where input for filtering Company queries.
type CompanyWhereInput struct {
	Predicates []predicate.Company  `json:"-"`
	Not        *CompanyWhereInput   `json:"not,omitempty"`
	Or         []*CompanyWhereInput `json:"or,omitempty"`
	And        []*CompanyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CompanyWhereInput) AddPredicates(predicates ...predicate.Company) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CompanyWhereInput filter on the CompanyQuery builder.
func (i *CompanyWhereInput) Filter(q *CompanyQuery) (*CompanyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCompanyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCompanyWhereInput is returned in case the CompanyWhereInput is empty.
var ErrEmptyCompanyWhereInput = errors.New("ent: empty predicate CompanyWhereInput")

// P returns a predicate for filtering companies.
// An error is returned if the input is empty or invalid.
func (i *CompanyWhereInput) P() (predicate.Company, error) {
	var predicates []predicate.Company
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, company.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Company, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, company.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Company, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, company.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, company.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, company.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, company.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, company.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, company.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, company.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, company.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, company.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, company.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, company.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, company.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, company.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, company.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, company.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, company.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, company.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, company.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, company.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, company.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, company.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, company.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, company.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, company.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, company.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, company.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, company.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, company.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, company.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, company.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, company.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, company.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, company.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, company.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, company.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, company.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, company.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, company.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasEmployee != nil {
		p := company.HasEmployee()
		if !*i.HasEmployee {
			p = company.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, company.HasEmployeeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCompanyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return company.And(predicates...), nil
	}
}

// CostumerWhereInput represents a where input for filtering Costumer queries.
type CostumerWhereInput struct {
	Predicates []predicate.Costumer  `json:"-"`
	Not        *CostumerWhereInput   `json:"not,omitempty"`
	Or         []*CostumerWhereInput `json:"or,omitempty"`
	And        []*CostumerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deals" edge predicates.
	HasDeals     *bool             `json:"hasDeals,omitempty"`
	HasDealsWith []*DealWhereInput `json:"hasDealsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CostumerWhereInput) AddPredicates(predicates ...predicate.Costumer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CostumerWhereInput filter on the CostumerQuery builder.
func (i *CostumerWhereInput) Filter(q *CostumerQuery) (*CostumerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCostumerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCostumerWhereInput is returned in case the CostumerWhereInput is empty.
var ErrEmptyCostumerWhereInput = errors.New("ent: empty predicate CostumerWhereInput")

// P returns a predicate for filtering costumers.
// An error is returned if the input is empty or invalid.
func (i *CostumerWhereInput) P() (predicate.Costumer, error) {
	var predicates []predicate.Costumer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, costumer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Costumer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, costumer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Costumer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, costumer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, costumer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, costumer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, costumer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, costumer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, costumer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, costumer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, costumer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, costumer.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, costumer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, costumer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, costumer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, costumer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, costumer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, costumer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, costumer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, costumer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, costumer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, costumer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, costumer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, costumer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, costumer.NameContainsFold(*i.NameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, costumer.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, costumer.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, costumer.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, costumer.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, costumer.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, costumer.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, costumer.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, costumer.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, costumer.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, costumer.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, costumer.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, costumer.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, costumer.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, costumer.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, costumer.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, costumer.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, costumer.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, costumer.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, costumer.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, costumer.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, costumer.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, costumer.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, costumer.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, costumer.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, costumer.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, costumer.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, costumer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, costumer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, costumer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, costumer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, costumer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, costumer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, costumer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, costumer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, costumer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, costumer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, costumer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, costumer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, costumer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, costumer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, costumer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, costumer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasDeals != nil {
		p := costumer.HasDeals()
		if !*i.HasDeals {
			p = costumer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDealsWith) > 0 {
		with := make([]predicate.Deal, 0, len(i.HasDealsWith))
		for _, w := range i.HasDealsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDealsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, costumer.HasDealsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCostumerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return costumer.And(predicates...), nil
	}
}

// CrmFieldWhereInput represents a where input for filtering CrmField queries.
type CrmFieldWhereInput struct {
	Predicates []predicate.CrmField  `json:"-"`
	Not        *CrmFieldWhereInput   `json:"not,omitempty"`
	Or         []*CrmFieldWhereInput `json:"or,omitempty"`
	And        []*CrmFieldWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "section" field predicates.
	Section             *string  `json:"section,omitempty"`
	SectionNEQ          *string  `json:"sectionNEQ,omitempty"`
	SectionIn           []string `json:"sectionIn,omitempty"`
	SectionNotIn        []string `json:"sectionNotIn,omitempty"`
	SectionGT           *string  `json:"sectionGT,omitempty"`
	SectionGTE          *string  `json:"sectionGTE,omitempty"`
	SectionLT           *string  `json:"sectionLT,omitempty"`
	SectionLTE          *string  `json:"sectionLTE,omitempty"`
	SectionContains     *string  `json:"sectionContains,omitempty"`
	SectionHasPrefix    *string  `json:"sectionHasPrefix,omitempty"`
	SectionHasSuffix    *string  `json:"sectionHasSuffix,omitempty"`
	SectionEqualFold    *string  `json:"sectionEqualFold,omitempty"`
	SectionContainsFold *string  `json:"sectionContainsFold,omitempty"`

	// "type" field predicates.
	Type      *crmfield.Type  `json:"type,omitempty"`
	TypeNEQ   *crmfield.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []crmfield.Type `json:"typeIn,omitempty"`
	TypeNotIn []crmfield.Type `json:"typeNotIn,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "dropdownList" edge predicates.
	HasDropdownList     *bool                     `json:"hasDropdownList,omitempty"`
	HasDropdownListWith []*DropdownListWhereInput `json:"hasDropdownListWith,omitempty"`

	// "dealCrmField" edge predicates.
	HasDealCrmField     *bool                     `json:"hasDealCrmField,omitempty"`
	HasDealCrmFieldWith []*DealCrmFieldWhereInput `json:"hasDealCrmFieldWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CrmFieldWhereInput) AddPredicates(predicates ...predicate.CrmField) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CrmFieldWhereInput filter on the CrmFieldQuery builder.
func (i *CrmFieldWhereInput) Filter(q *CrmFieldQuery) (*CrmFieldQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCrmFieldWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCrmFieldWhereInput is returned in case the CrmFieldWhereInput is empty.
var ErrEmptyCrmFieldWhereInput = errors.New("ent: empty predicate CrmFieldWhereInput")

// P returns a predicate for filtering crmfields.
// An error is returned if the input is empty or invalid.
func (i *CrmFieldWhereInput) P() (predicate.CrmField, error) {
	var predicates []predicate.CrmField
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, crmfield.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CrmField, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, crmfield.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CrmField, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, crmfield.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, crmfield.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, crmfield.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, crmfield.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, crmfield.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, crmfield.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, crmfield.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, crmfield.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, crmfield.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, crmfield.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, crmfield.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, crmfield.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, crmfield.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, crmfield.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, crmfield.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, crmfield.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, crmfield.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, crmfield.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, crmfield.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, crmfield.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, crmfield.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, crmfield.NameContainsFold(*i.NameContainsFold))
	}
	if i.Section != nil {
		predicates = append(predicates, crmfield.SectionEQ(*i.Section))
	}
	if i.SectionNEQ != nil {
		predicates = append(predicates, crmfield.SectionNEQ(*i.SectionNEQ))
	}
	if len(i.SectionIn) > 0 {
		predicates = append(predicates, crmfield.SectionIn(i.SectionIn...))
	}
	if len(i.SectionNotIn) > 0 {
		predicates = append(predicates, crmfield.SectionNotIn(i.SectionNotIn...))
	}
	if i.SectionGT != nil {
		predicates = append(predicates, crmfield.SectionGT(*i.SectionGT))
	}
	if i.SectionGTE != nil {
		predicates = append(predicates, crmfield.SectionGTE(*i.SectionGTE))
	}
	if i.SectionLT != nil {
		predicates = append(predicates, crmfield.SectionLT(*i.SectionLT))
	}
	if i.SectionLTE != nil {
		predicates = append(predicates, crmfield.SectionLTE(*i.SectionLTE))
	}
	if i.SectionContains != nil {
		predicates = append(predicates, crmfield.SectionContains(*i.SectionContains))
	}
	if i.SectionHasPrefix != nil {
		predicates = append(predicates, crmfield.SectionHasPrefix(*i.SectionHasPrefix))
	}
	if i.SectionHasSuffix != nil {
		predicates = append(predicates, crmfield.SectionHasSuffix(*i.SectionHasSuffix))
	}
	if i.SectionEqualFold != nil {
		predicates = append(predicates, crmfield.SectionEqualFold(*i.SectionEqualFold))
	}
	if i.SectionContainsFold != nil {
		predicates = append(predicates, crmfield.SectionContainsFold(*i.SectionContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, crmfield.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, crmfield.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, crmfield.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, crmfield.TypeNotIn(i.TypeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, crmfield.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, crmfield.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, crmfield.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, crmfield.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, crmfield.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, crmfield.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, crmfield.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, crmfield.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, crmfield.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, crmfield.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, crmfield.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, crmfield.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, crmfield.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, crmfield.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, crmfield.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, crmfield.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasDropdownList != nil {
		p := crmfield.HasDropdownList()
		if !*i.HasDropdownList {
			p = crmfield.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDropdownListWith) > 0 {
		with := make([]predicate.DropdownList, 0, len(i.HasDropdownListWith))
		for _, w := range i.HasDropdownListWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDropdownListWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, crmfield.HasDropdownListWith(with...))
	}
	if i.HasDealCrmField != nil {
		p := crmfield.HasDealCrmField()
		if !*i.HasDealCrmField {
			p = crmfield.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDealCrmFieldWith) > 0 {
		with := make([]predicate.DealCrmField, 0, len(i.HasDealCrmFieldWith))
		for _, w := range i.HasDealCrmFieldWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDealCrmFieldWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, crmfield.HasDealCrmFieldWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCrmFieldWhereInput
	case 1:
		return predicates[0], nil
	default:
		return crmfield.And(predicates...), nil
	}
}

// DealWhereInput represents a where input for filtering Deal queries.
type DealWhereInput struct {
	Predicates []predicate.Deal  `json:"-"`
	Not        *DealWhereInput   `json:"not,omitempty"`
	Or         []*DealWhereInput `json:"or,omitempty"`
	And        []*DealWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "costumer" edge predicates.
	HasCostumer     *bool                 `json:"hasCostumer,omitempty"`
	HasCostumerWith []*CostumerWhereInput `json:"hasCostumerWith,omitempty"`

	// "chat" edge predicates.
	HasChat     *bool             `json:"hasChat,omitempty"`
	HasChatWith []*ChatWhereInput `json:"hasChatWith,omitempty"`

	// "stage" edge predicates.
	HasStage     *bool              `json:"hasStage,omitempty"`
	HasStageWith []*StageWhereInput `json:"hasStageWith,omitempty"`

	// "dealCrmFields" edge predicates.
	HasDealCrmFields     *bool                     `json:"hasDealCrmFields,omitempty"`
	HasDealCrmFieldsWith []*DealCrmFieldWhereInput `json:"hasDealCrmFieldsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DealWhereInput) AddPredicates(predicates ...predicate.Deal) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DealWhereInput filter on the DealQuery builder.
func (i *DealWhereInput) Filter(q *DealQuery) (*DealQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDealWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDealWhereInput is returned in case the DealWhereInput is empty.
var ErrEmptyDealWhereInput = errors.New("ent: empty predicate DealWhereInput")

// P returns a predicate for filtering deals.
// An error is returned if the input is empty or invalid.
func (i *DealWhereInput) P() (predicate.Deal, error) {
	var predicates []predicate.Deal
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deal.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Deal, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deal.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Deal, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deal.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deal.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deal.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deal.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deal.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deal.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deal.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deal.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deal.IDLTE(*i.IDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, deal.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, deal.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, deal.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, deal.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, deal.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, deal.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, deal.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, deal.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, deal.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, deal.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, deal.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, deal.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, deal.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Source != nil {
		predicates = append(predicates, deal.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, deal.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, deal.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, deal.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, deal.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, deal.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, deal.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, deal.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, deal.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, deal.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, deal.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, deal.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, deal.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, deal.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, deal.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, deal.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, deal.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, deal.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, deal.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, deal.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, deal.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, deal.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, deal.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, deal.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, deal.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, deal.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, deal.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, deal.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, deal.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasCostumer != nil {
		p := deal.HasCostumer()
		if !*i.HasCostumer {
			p = deal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCostumerWith) > 0 {
		with := make([]predicate.Costumer, 0, len(i.HasCostumerWith))
		for _, w := range i.HasCostumerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCostumerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deal.HasCostumerWith(with...))
	}
	if i.HasChat != nil {
		p := deal.HasChat()
		if !*i.HasChat {
			p = deal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChatWith) > 0 {
		with := make([]predicate.Chat, 0, len(i.HasChatWith))
		for _, w := range i.HasChatWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChatWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deal.HasChatWith(with...))
	}
	if i.HasStage != nil {
		p := deal.HasStage()
		if !*i.HasStage {
			p = deal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStageWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStageWith))
		for _, w := range i.HasStageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deal.HasStageWith(with...))
	}
	if i.HasDealCrmFields != nil {
		p := deal.HasDealCrmFields()
		if !*i.HasDealCrmFields {
			p = deal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDealCrmFieldsWith) > 0 {
		with := make([]predicate.DealCrmField, 0, len(i.HasDealCrmFieldsWith))
		for _, w := range i.HasDealCrmFieldsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDealCrmFieldsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deal.HasDealCrmFieldsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDealWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deal.And(predicates...), nil
	}
}

// DealCrmFieldWhereInput represents a where input for filtering DealCrmField queries.
type DealCrmFieldWhereInput struct {
	Predicates []predicate.DealCrmField  `json:"-"`
	Not        *DealCrmFieldWhereInput   `json:"not,omitempty"`
	Or         []*DealCrmFieldWhereInput `json:"or,omitempty"`
	And        []*DealCrmFieldWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "deal" edge predicates.
	HasDeal     *bool             `json:"hasDeal,omitempty"`
	HasDealWith []*DealWhereInput `json:"hasDealWith,omitempty"`

	// "crmField" edge predicates.
	HasCrmField     *bool                 `json:"hasCrmField,omitempty"`
	HasCrmFieldWith []*CrmFieldWhereInput `json:"hasCrmFieldWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DealCrmFieldWhereInput) AddPredicates(predicates ...predicate.DealCrmField) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DealCrmFieldWhereInput filter on the DealCrmFieldQuery builder.
func (i *DealCrmFieldWhereInput) Filter(q *DealCrmFieldQuery) (*DealCrmFieldQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDealCrmFieldWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDealCrmFieldWhereInput is returned in case the DealCrmFieldWhereInput is empty.
var ErrEmptyDealCrmFieldWhereInput = errors.New("ent: empty predicate DealCrmFieldWhereInput")

// P returns a predicate for filtering dealcrmfields.
// An error is returned if the input is empty or invalid.
func (i *DealCrmFieldWhereInput) P() (predicate.DealCrmField, error) {
	var predicates []predicate.DealCrmField
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dealcrmfield.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DealCrmField, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dealcrmfield.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DealCrmField, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dealcrmfield.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dealcrmfield.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dealcrmfield.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dealcrmfield.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dealcrmfield.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dealcrmfield.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dealcrmfield.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dealcrmfield.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dealcrmfield.IDLTE(*i.IDLTE))
	}
	if i.Value != nil {
		predicates = append(predicates, dealcrmfield.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, dealcrmfield.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, dealcrmfield.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, dealcrmfield.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, dealcrmfield.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, dealcrmfield.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, dealcrmfield.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, dealcrmfield.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, dealcrmfield.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, dealcrmfield.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, dealcrmfield.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, dealcrmfield.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, dealcrmfield.ValueContainsFold(*i.ValueContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, dealcrmfield.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, dealcrmfield.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, dealcrmfield.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, dealcrmfield.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, dealcrmfield.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, dealcrmfield.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, dealcrmfield.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, dealcrmfield.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, dealcrmfield.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, dealcrmfield.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, dealcrmfield.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, dealcrmfield.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, dealcrmfield.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, dealcrmfield.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, dealcrmfield.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, dealcrmfield.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasDeal != nil {
		p := dealcrmfield.HasDeal()
		if !*i.HasDeal {
			p = dealcrmfield.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDealWith) > 0 {
		with := make([]predicate.Deal, 0, len(i.HasDealWith))
		for _, w := range i.HasDealWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDealWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dealcrmfield.HasDealWith(with...))
	}
	if i.HasCrmField != nil {
		p := dealcrmfield.HasCrmField()
		if !*i.HasCrmField {
			p = dealcrmfield.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCrmFieldWith) > 0 {
		with := make([]predicate.CrmField, 0, len(i.HasCrmFieldWith))
		for _, w := range i.HasCrmFieldWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCrmFieldWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dealcrmfield.HasCrmFieldWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDealCrmFieldWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dealcrmfield.And(predicates...), nil
	}
}

// DepartmentWhereInput represents a where input for filtering Department queries.
type DepartmentWhereInput struct {
	Predicates []predicate.Department  `json:"-"`
	Not        *DepartmentWhereInput   `json:"not,omitempty"`
	Or         []*DepartmentWhereInput `json:"or,omitempty"`
	And        []*DepartmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`

	// "queues" edge predicates.
	HasQueues     *bool              `json:"hasQueues,omitempty"`
	HasQueuesWith []*QueueWhereInput `json:"hasQueuesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DepartmentWhereInput) AddPredicates(predicates ...predicate.Department) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DepartmentWhereInput filter on the DepartmentQuery builder.
func (i *DepartmentWhereInput) Filter(q *DepartmentQuery) (*DepartmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDepartmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDepartmentWhereInput is returned in case the DepartmentWhereInput is empty.
var ErrEmptyDepartmentWhereInput = errors.New("ent: empty predicate DepartmentWhereInput")

// P returns a predicate for filtering departments.
// An error is returned if the input is empty or invalid.
func (i *DepartmentWhereInput) P() (predicate.Department, error) {
	var predicates []predicate.Department
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, department.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Department, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, department.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Department, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, department.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, department.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, department.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, department.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, department.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, department.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, department.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, department.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, department.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, department.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, department.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, department.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, department.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, department.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, department.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, department.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, department.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, department.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, department.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, department.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, department.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, department.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, department.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, department.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, department.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, department.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, department.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, department.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, department.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, department.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, department.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, department.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, department.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, department.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, department.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, department.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, department.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, department.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasEmployee != nil {
		p := department.HasEmployee()
		if !*i.HasEmployee {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasEmployeeWith(with...))
	}
	if i.HasQueues != nil {
		p := department.HasQueues()
		if !*i.HasQueues {
			p = department.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQueuesWith) > 0 {
		with := make([]predicate.Queue, 0, len(i.HasQueuesWith))
		for _, w := range i.HasQueuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQueuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, department.HasQueuesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDepartmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return department.And(predicates...), nil
	}
}

// DropdownListWhereInput represents a where input for filtering DropdownList queries.
type DropdownListWhereInput struct {
	Predicates []predicate.DropdownList  `json:"-"`
	Not        *DropdownListWhereInput   `json:"not,omitempty"`
	Or         []*DropdownListWhereInput `json:"or,omitempty"`
	And        []*DropdownListWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "crmField" edge predicates.
	HasCrmField     *bool                 `json:"hasCrmField,omitempty"`
	HasCrmFieldWith []*CrmFieldWhereInput `json:"hasCrmFieldWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DropdownListWhereInput) AddPredicates(predicates ...predicate.DropdownList) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DropdownListWhereInput filter on the DropdownListQuery builder.
func (i *DropdownListWhereInput) Filter(q *DropdownListQuery) (*DropdownListQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDropdownListWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDropdownListWhereInput is returned in case the DropdownListWhereInput is empty.
var ErrEmptyDropdownListWhereInput = errors.New("ent: empty predicate DropdownListWhereInput")

// P returns a predicate for filtering dropdownlists.
// An error is returned if the input is empty or invalid.
func (i *DropdownListWhereInput) P() (predicate.DropdownList, error) {
	var predicates []predicate.DropdownList
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dropdownlist.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DropdownList, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dropdownlist.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DropdownList, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dropdownlist.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dropdownlist.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dropdownlist.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dropdownlist.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dropdownlist.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dropdownlist.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dropdownlist.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dropdownlist.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dropdownlist.IDLTE(*i.IDLTE))
	}
	if i.Value != nil {
		predicates = append(predicates, dropdownlist.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, dropdownlist.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, dropdownlist.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, dropdownlist.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, dropdownlist.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, dropdownlist.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, dropdownlist.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, dropdownlist.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, dropdownlist.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, dropdownlist.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, dropdownlist.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, dropdownlist.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, dropdownlist.ValueContainsFold(*i.ValueContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, dropdownlist.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, dropdownlist.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, dropdownlist.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, dropdownlist.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, dropdownlist.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, dropdownlist.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, dropdownlist.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, dropdownlist.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, dropdownlist.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, dropdownlist.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, dropdownlist.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, dropdownlist.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, dropdownlist.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, dropdownlist.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, dropdownlist.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, dropdownlist.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasCrmField != nil {
		p := dropdownlist.HasCrmField()
		if !*i.HasCrmField {
			p = dropdownlist.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCrmFieldWith) > 0 {
		with := make([]predicate.CrmField, 0, len(i.HasCrmFieldWith))
		for _, w := range i.HasCrmFieldWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCrmFieldWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dropdownlist.HasCrmFieldWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDropdownListWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dropdownlist.And(predicates...), nil
	}
}

// EmployeeWhereInput represents a where input for filtering Employee queries.
type EmployeeWhereInput struct {
	Predicates []predicate.Employee  `json:"-"`
	Not        *EmployeeWhereInput   `json:"not,omitempty"`
	Or         []*EmployeeWhereInput `json:"or,omitempty"`
	And        []*EmployeeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "employeeAuth" edge predicates.
	HasEmployeeAuth     *bool                     `json:"hasEmployeeAuth,omitempty"`
	HasEmployeeAuthWith []*EmployeeAuthWhereInput `json:"hasEmployeeAuthWith,omitempty"`

	// "company" edge predicates.
	HasCompany     *bool                `json:"hasCompany,omitempty"`
	HasCompanyWith []*CompanyWhereInput `json:"hasCompanyWith,omitempty"`

	// "department" edge predicates.
	HasDepartment     *bool                   `json:"hasDepartment,omitempty"`
	HasDepartmentWith []*DepartmentWhereInput `json:"hasDepartmentWith,omitempty"`

	// "chat" edge predicates.
	HasChat     *bool             `json:"hasChat,omitempty"`
	HasChatWith []*ChatWhereInput `json:"hasChatWith,omitempty"`

	// "queues" edge predicates.
	HasQueues     *bool              `json:"hasQueues,omitempty"`
	HasQueuesWith []*QueueWhereInput `json:"hasQueuesWith,omitempty"`

	// "messages" edge predicates.
	HasMessages     *bool                `json:"hasMessages,omitempty"`
	HasMessagesWith []*MessageWhereInput `json:"hasMessagesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmployeeWhereInput) AddPredicates(predicates ...predicate.Employee) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmployeeWhereInput filter on the EmployeeQuery builder.
func (i *EmployeeWhereInput) Filter(q *EmployeeQuery) (*EmployeeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmployeeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmployeeWhereInput is returned in case the EmployeeWhereInput is empty.
var ErrEmptyEmployeeWhereInput = errors.New("ent: empty predicate EmployeeWhereInput")

// P returns a predicate for filtering employees.
// An error is returned if the input is empty or invalid.
func (i *EmployeeWhereInput) P() (predicate.Employee, error) {
	var predicates []predicate.Employee
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, employee.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Employee, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, employee.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Employee, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, employee.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, employee.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, employee.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, employee.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, employee.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, employee.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, employee.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, employee.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, employee.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, employee.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, employee.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, employee.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, employee.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, employee.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, employee.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, employee.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, employee.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, employee.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, employee.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, employee.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, employee.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, employee.NameContainsFold(*i.NameContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, employee.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, employee.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, employee.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, employee.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, employee.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, employee.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, employee.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, employee.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, employee.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, employee.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, employee.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, employee.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, employee.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, employee.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, employee.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, employee.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, employee.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasEmployeeAuth != nil {
		p := employee.HasEmployeeAuth()
		if !*i.HasEmployeeAuth {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeAuthWith) > 0 {
		with := make([]predicate.EmployeeAuth, 0, len(i.HasEmployeeAuthWith))
		for _, w := range i.HasEmployeeAuthWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeAuthWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasEmployeeAuthWith(with...))
	}
	if i.HasCompany != nil {
		p := employee.HasCompany()
		if !*i.HasCompany {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyWith) > 0 {
		with := make([]predicate.Company, 0, len(i.HasCompanyWith))
		for _, w := range i.HasCompanyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasCompanyWith(with...))
	}
	if i.HasDepartment != nil {
		p := employee.HasDepartment()
		if !*i.HasDepartment {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDepartmentWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasDepartmentWith))
		for _, w := range i.HasDepartmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDepartmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasDepartmentWith(with...))
	}
	if i.HasChat != nil {
		p := employee.HasChat()
		if !*i.HasChat {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChatWith) > 0 {
		with := make([]predicate.Chat, 0, len(i.HasChatWith))
		for _, w := range i.HasChatWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChatWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasChatWith(with...))
	}
	if i.HasQueues != nil {
		p := employee.HasQueues()
		if !*i.HasQueues {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQueuesWith) > 0 {
		with := make([]predicate.Queue, 0, len(i.HasQueuesWith))
		for _, w := range i.HasQueuesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQueuesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasQueuesWith(with...))
	}
	if i.HasMessages != nil {
		p := employee.HasMessages()
		if !*i.HasMessages {
			p = employee.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessagesWith) > 0 {
		with := make([]predicate.Message, 0, len(i.HasMessagesWith))
		for _, w := range i.HasMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMessagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employee.HasMessagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmployeeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return employee.And(predicates...), nil
	}
}

// EmployeeAuthWhereInput represents a where input for filtering EmployeeAuth queries.
type EmployeeAuthWhereInput struct {
	Predicates []predicate.EmployeeAuth  `json:"-"`
	Not        *EmployeeAuthWhereInput   `json:"not,omitempty"`
	Or         []*EmployeeAuthWhereInput `json:"or,omitempty"`
	And        []*EmployeeAuthWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmployeeAuthWhereInput) AddPredicates(predicates ...predicate.EmployeeAuth) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmployeeAuthWhereInput filter on the EmployeeAuthQuery builder.
func (i *EmployeeAuthWhereInput) Filter(q *EmployeeAuthQuery) (*EmployeeAuthQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmployeeAuthWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmployeeAuthWhereInput is returned in case the EmployeeAuthWhereInput is empty.
var ErrEmptyEmployeeAuthWhereInput = errors.New("ent: empty predicate EmployeeAuthWhereInput")

// P returns a predicate for filtering employeeauths.
// An error is returned if the input is empty or invalid.
func (i *EmployeeAuthWhereInput) P() (predicate.EmployeeAuth, error) {
	var predicates []predicate.EmployeeAuth
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, employeeauth.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EmployeeAuth, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, employeeauth.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EmployeeAuth, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, employeeauth.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, employeeauth.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, employeeauth.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, employeeauth.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, employeeauth.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, employeeauth.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, employeeauth.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, employeeauth.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, employeeauth.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, employeeauth.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, employeeauth.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, employeeauth.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, employeeauth.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, employeeauth.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, employeeauth.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, employeeauth.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, employeeauth.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, employeeauth.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, employeeauth.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, employeeauth.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, employeeauth.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, employeeauth.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, employeeauth.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, employeeauth.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, employeeauth.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, employeeauth.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, employeeauth.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, employeeauth.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, employeeauth.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, employeeauth.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, employeeauth.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, employeeauth.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, employeeauth.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, employeeauth.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, employeeauth.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, employeeauth.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, employeeauth.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, employeeauth.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, employeeauth.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, employeeauth.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, employeeauth.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, employeeauth.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, employeeauth.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, employeeauth.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, employeeauth.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, employeeauth.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, employeeauth.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, employeeauth.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, employeeauth.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, employeeauth.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, employeeauth.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, employeeauth.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, employeeauth.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, employeeauth.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, employeeauth.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, employeeauth.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, employeeauth.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, employeeauth.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, employeeauth.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, employeeauth.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, employeeauth.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, employeeauth.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, employeeauth.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, employeeauth.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasEmployee != nil {
		p := employeeauth.HasEmployee()
		if !*i.HasEmployee {
			p = employeeauth.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, employeeauth.HasEmployeeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmployeeAuthWhereInput
	case 1:
		return predicates[0], nil
	default:
		return employeeauth.And(predicates...), nil
	}
}

// FileWhereInput represents a where input for filtering File queries.
type FileWhereInput struct {
	Predicates []predicate.File  `json:"-"`
	Not        *FileWhereInput   `json:"not,omitempty"`
	Or         []*FileWhereInput `json:"or,omitempty"`
	And        []*FileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "caption" field predicates.
	Caption             *string  `json:"caption,omitempty"`
	CaptionNEQ          *string  `json:"captionNEQ,omitempty"`
	CaptionIn           []string `json:"captionIn,omitempty"`
	CaptionNotIn        []string `json:"captionNotIn,omitempty"`
	CaptionGT           *string  `json:"captionGT,omitempty"`
	CaptionGTE          *string  `json:"captionGTE,omitempty"`
	CaptionLT           *string  `json:"captionLT,omitempty"`
	CaptionLTE          *string  `json:"captionLTE,omitempty"`
	CaptionContains     *string  `json:"captionContains,omitempty"`
	CaptionHasPrefix    *string  `json:"captionHasPrefix,omitempty"`
	CaptionHasSuffix    *string  `json:"captionHasSuffix,omitempty"`
	CaptionIsNil        bool     `json:"captionIsNil,omitempty"`
	CaptionNotNil       bool     `json:"captionNotNil,omitempty"`
	CaptionEqualFold    *string  `json:"captionEqualFold,omitempty"`
	CaptionContainsFold *string  `json:"captionContainsFold,omitempty"`

	// "mimeType" field predicates.
	MimeType             *string  `json:"mimetype,omitempty"`
	MimeTypeNEQ          *string  `json:"mimetypeNEQ,omitempty"`
	MimeTypeIn           []string `json:"mimetypeIn,omitempty"`
	MimeTypeNotIn        []string `json:"mimetypeNotIn,omitempty"`
	MimeTypeGT           *string  `json:"mimetypeGT,omitempty"`
	MimeTypeGTE          *string  `json:"mimetypeGTE,omitempty"`
	MimeTypeLT           *string  `json:"mimetypeLT,omitempty"`
	MimeTypeLTE          *string  `json:"mimetypeLTE,omitempty"`
	MimeTypeContains     *string  `json:"mimetypeContains,omitempty"`
	MimeTypeHasPrefix    *string  `json:"mimetypeHasPrefix,omitempty"`
	MimeTypeHasSuffix    *string  `json:"mimetypeHasSuffix,omitempty"`
	MimeTypeEqualFold    *string  `json:"mimetypeEqualFold,omitempty"`
	MimeTypeContainsFold *string  `json:"mimetypeContainsFold,omitempty"`

	// "fileName" field predicates.
	FileName             *string  `json:"filename,omitempty"`
	FileNameNEQ          *string  `json:"filenameNEQ,omitempty"`
	FileNameIn           []string `json:"filenameIn,omitempty"`
	FileNameNotIn        []string `json:"filenameNotIn,omitempty"`
	FileNameGT           *string  `json:"filenameGT,omitempty"`
	FileNameGTE          *string  `json:"filenameGTE,omitempty"`
	FileNameLT           *string  `json:"filenameLT,omitempty"`
	FileNameLTE          *string  `json:"filenameLTE,omitempty"`
	FileNameContains     *string  `json:"filenameContains,omitempty"`
	FileNameHasPrefix    *string  `json:"filenameHasPrefix,omitempty"`
	FileNameHasSuffix    *string  `json:"filenameHasSuffix,omitempty"`
	FileNameEqualFold    *string  `json:"filenameEqualFold,omitempty"`
	FileNameContainsFold *string  `json:"filenameContainsFold,omitempty"`

	// "message" edge predicates.
	HasMessage     *bool                `json:"hasMessage,omitempty"`
	HasMessageWith []*MessageWhereInput `json:"hasMessageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FileWhereInput) AddPredicates(predicates ...predicate.File) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FileWhereInput filter on the FileQuery builder.
func (i *FileWhereInput) Filter(q *FileQuery) (*FileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFileWhereInput is returned in case the FileWhereInput is empty.
var ErrEmptyFileWhereInput = errors.New("ent: empty predicate FileWhereInput")

// P returns a predicate for filtering files.
// An error is returned if the input is empty or invalid.
func (i *FileWhereInput) P() (predicate.File, error) {
	var predicates []predicate.File
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, file.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.File, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, file.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.File, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, file.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, file.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, file.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, file.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, file.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, file.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, file.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, file.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, file.IDLTE(*i.IDLTE))
	}
	if i.URL != nil {
		predicates = append(predicates, file.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, file.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, file.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, file.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, file.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, file.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, file.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, file.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, file.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, file.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, file.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, file.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, file.URLContainsFold(*i.URLContainsFold))
	}
	if i.Caption != nil {
		predicates = append(predicates, file.CaptionEQ(*i.Caption))
	}
	if i.CaptionNEQ != nil {
		predicates = append(predicates, file.CaptionNEQ(*i.CaptionNEQ))
	}
	if len(i.CaptionIn) > 0 {
		predicates = append(predicates, file.CaptionIn(i.CaptionIn...))
	}
	if len(i.CaptionNotIn) > 0 {
		predicates = append(predicates, file.CaptionNotIn(i.CaptionNotIn...))
	}
	if i.CaptionGT != nil {
		predicates = append(predicates, file.CaptionGT(*i.CaptionGT))
	}
	if i.CaptionGTE != nil {
		predicates = append(predicates, file.CaptionGTE(*i.CaptionGTE))
	}
	if i.CaptionLT != nil {
		predicates = append(predicates, file.CaptionLT(*i.CaptionLT))
	}
	if i.CaptionLTE != nil {
		predicates = append(predicates, file.CaptionLTE(*i.CaptionLTE))
	}
	if i.CaptionContains != nil {
		predicates = append(predicates, file.CaptionContains(*i.CaptionContains))
	}
	if i.CaptionHasPrefix != nil {
		predicates = append(predicates, file.CaptionHasPrefix(*i.CaptionHasPrefix))
	}
	if i.CaptionHasSuffix != nil {
		predicates = append(predicates, file.CaptionHasSuffix(*i.CaptionHasSuffix))
	}
	if i.CaptionIsNil {
		predicates = append(predicates, file.CaptionIsNil())
	}
	if i.CaptionNotNil {
		predicates = append(predicates, file.CaptionNotNil())
	}
	if i.CaptionEqualFold != nil {
		predicates = append(predicates, file.CaptionEqualFold(*i.CaptionEqualFold))
	}
	if i.CaptionContainsFold != nil {
		predicates = append(predicates, file.CaptionContainsFold(*i.CaptionContainsFold))
	}
	if i.MimeType != nil {
		predicates = append(predicates, file.MimeTypeEQ(*i.MimeType))
	}
	if i.MimeTypeNEQ != nil {
		predicates = append(predicates, file.MimeTypeNEQ(*i.MimeTypeNEQ))
	}
	if len(i.MimeTypeIn) > 0 {
		predicates = append(predicates, file.MimeTypeIn(i.MimeTypeIn...))
	}
	if len(i.MimeTypeNotIn) > 0 {
		predicates = append(predicates, file.MimeTypeNotIn(i.MimeTypeNotIn...))
	}
	if i.MimeTypeGT != nil {
		predicates = append(predicates, file.MimeTypeGT(*i.MimeTypeGT))
	}
	if i.MimeTypeGTE != nil {
		predicates = append(predicates, file.MimeTypeGTE(*i.MimeTypeGTE))
	}
	if i.MimeTypeLT != nil {
		predicates = append(predicates, file.MimeTypeLT(*i.MimeTypeLT))
	}
	if i.MimeTypeLTE != nil {
		predicates = append(predicates, file.MimeTypeLTE(*i.MimeTypeLTE))
	}
	if i.MimeTypeContains != nil {
		predicates = append(predicates, file.MimeTypeContains(*i.MimeTypeContains))
	}
	if i.MimeTypeHasPrefix != nil {
		predicates = append(predicates, file.MimeTypeHasPrefix(*i.MimeTypeHasPrefix))
	}
	if i.MimeTypeHasSuffix != nil {
		predicates = append(predicates, file.MimeTypeHasSuffix(*i.MimeTypeHasSuffix))
	}
	if i.MimeTypeEqualFold != nil {
		predicates = append(predicates, file.MimeTypeEqualFold(*i.MimeTypeEqualFold))
	}
	if i.MimeTypeContainsFold != nil {
		predicates = append(predicates, file.MimeTypeContainsFold(*i.MimeTypeContainsFold))
	}
	if i.FileName != nil {
		predicates = append(predicates, file.FileNameEQ(*i.FileName))
	}
	if i.FileNameNEQ != nil {
		predicates = append(predicates, file.FileNameNEQ(*i.FileNameNEQ))
	}
	if len(i.FileNameIn) > 0 {
		predicates = append(predicates, file.FileNameIn(i.FileNameIn...))
	}
	if len(i.FileNameNotIn) > 0 {
		predicates = append(predicates, file.FileNameNotIn(i.FileNameNotIn...))
	}
	if i.FileNameGT != nil {
		predicates = append(predicates, file.FileNameGT(*i.FileNameGT))
	}
	if i.FileNameGTE != nil {
		predicates = append(predicates, file.FileNameGTE(*i.FileNameGTE))
	}
	if i.FileNameLT != nil {
		predicates = append(predicates, file.FileNameLT(*i.FileNameLT))
	}
	if i.FileNameLTE != nil {
		predicates = append(predicates, file.FileNameLTE(*i.FileNameLTE))
	}
	if i.FileNameContains != nil {
		predicates = append(predicates, file.FileNameContains(*i.FileNameContains))
	}
	if i.FileNameHasPrefix != nil {
		predicates = append(predicates, file.FileNameHasPrefix(*i.FileNameHasPrefix))
	}
	if i.FileNameHasSuffix != nil {
		predicates = append(predicates, file.FileNameHasSuffix(*i.FileNameHasSuffix))
	}
	if i.FileNameEqualFold != nil {
		predicates = append(predicates, file.FileNameEqualFold(*i.FileNameEqualFold))
	}
	if i.FileNameContainsFold != nil {
		predicates = append(predicates, file.FileNameContainsFold(*i.FileNameContainsFold))
	}

	if i.HasMessage != nil {
		p := file.HasMessage()
		if !*i.HasMessage {
			p = file.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessageWith) > 0 {
		with := make([]predicate.Message, 0, len(i.HasMessageWith))
		for _, w := range i.HasMessageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMessageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, file.HasMessageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return file.And(predicates...), nil
	}
}

// MessageWhereInput represents a where input for filtering Message queries.
type MessageWhereInput struct {
	Predicates []predicate.Message  `json:"-"`
	Not        *MessageWhereInput   `json:"not,omitempty"`
	Or         []*MessageWhereInput `json:"or,omitempty"`
	And        []*MessageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "sentBy" field predicates.
	SentBy      *message.SentBy  `json:"sentby,omitempty"`
	SentByNEQ   *message.SentBy  `json:"sentbyNEQ,omitempty"`
	SentByIn    []message.SentBy `json:"sentbyIn,omitempty"`
	SentByNotIn []message.SentBy `json:"sentbyNotIn,omitempty"`

	// "private" field predicates.
	Private    *bool `json:"private,omitempty"`
	PrivateNEQ *bool `json:"privateNEQ,omitempty"`

	// "type" field predicates.
	Type      *message.Type  `json:"type,omitempty"`
	TypeNEQ   *message.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []message.Type `json:"typeIn,omitempty"`
	TypeNotIn []message.Type `json:"typeNotIn,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "chat" edge predicates.
	HasChat     *bool             `json:"hasChat,omitempty"`
	HasChatWith []*ChatWhereInput `json:"hasChatWith,omitempty"`

	// "employee" edge predicates.
	HasEmployee     *bool                 `json:"hasEmployee,omitempty"`
	HasEmployeeWith []*EmployeeWhereInput `json:"hasEmployeeWith,omitempty"`

	// "text" edge predicates.
	HasText     *bool             `json:"hasText,omitempty"`
	HasTextWith []*TextWhereInput `json:"hasTextWith,omitempty"`

	// "file" edge predicates.
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MessageWhereInput) AddPredicates(predicates ...predicate.Message) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MessageWhereInput filter on the MessageQuery builder.
func (i *MessageWhereInput) Filter(q *MessageQuery) (*MessageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMessageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMessageWhereInput is returned in case the MessageWhereInput is empty.
var ErrEmptyMessageWhereInput = errors.New("ent: empty predicate MessageWhereInput")

// P returns a predicate for filtering messages.
// An error is returned if the input is empty or invalid.
func (i *MessageWhereInput) P() (predicate.Message, error) {
	var predicates []predicate.Message
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, message.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Message, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, message.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Message, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, message.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, message.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, message.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, message.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, message.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, message.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, message.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, message.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, message.IDLTE(*i.IDLTE))
	}
	if i.SentBy != nil {
		predicates = append(predicates, message.SentByEQ(*i.SentBy))
	}
	if i.SentByNEQ != nil {
		predicates = append(predicates, message.SentByNEQ(*i.SentByNEQ))
	}
	if len(i.SentByIn) > 0 {
		predicates = append(predicates, message.SentByIn(i.SentByIn...))
	}
	if len(i.SentByNotIn) > 0 {
		predicates = append(predicates, message.SentByNotIn(i.SentByNotIn...))
	}
	if i.Private != nil {
		predicates = append(predicates, message.PrivateEQ(*i.Private))
	}
	if i.PrivateNEQ != nil {
		predicates = append(predicates, message.PrivateNEQ(*i.PrivateNEQ))
	}
	if i.Type != nil {
		predicates = append(predicates, message.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, message.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, message.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, message.TypeNotIn(i.TypeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, message.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, message.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, message.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, message.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, message.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, message.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, message.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, message.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, message.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, message.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, message.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, message.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, message.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, message.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, message.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, message.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasChat != nil {
		p := message.HasChat()
		if !*i.HasChat {
			p = message.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChatWith) > 0 {
		with := make([]predicate.Chat, 0, len(i.HasChatWith))
		for _, w := range i.HasChatWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChatWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, message.HasChatWith(with...))
	}
	if i.HasEmployee != nil {
		p := message.HasEmployee()
		if !*i.HasEmployee {
			p = message.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeeWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeeWith))
		for _, w := range i.HasEmployeeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, message.HasEmployeeWith(with...))
	}
	if i.HasText != nil {
		p := message.HasText()
		if !*i.HasText {
			p = message.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTextWith) > 0 {
		with := make([]predicate.Text, 0, len(i.HasTextWith))
		for _, w := range i.HasTextWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTextWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, message.HasTextWith(with...))
	}
	if i.HasFile != nil {
		p := message.HasFile()
		if !*i.HasFile {
			p = message.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFileWith) > 0 {
		with := make([]predicate.File, 0, len(i.HasFileWith))
		for _, w := range i.HasFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, message.HasFileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMessageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return message.And(predicates...), nil
	}
}

// PipelineWhereInput represents a where input for filtering Pipeline queries.
type PipelineWhereInput struct {
	Predicates []predicate.Pipeline  `json:"-"`
	Not        *PipelineWhereInput   `json:"not,omitempty"`
	Or         []*PipelineWhereInput `json:"or,omitempty"`
	And        []*PipelineWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "stages" edge predicates.
	HasStages     *bool              `json:"hasStages,omitempty"`
	HasStagesWith []*StageWhereInput `json:"hasStagesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PipelineWhereInput) AddPredicates(predicates ...predicate.Pipeline) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PipelineWhereInput filter on the PipelineQuery builder.
func (i *PipelineWhereInput) Filter(q *PipelineQuery) (*PipelineQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPipelineWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPipelineWhereInput is returned in case the PipelineWhereInput is empty.
var ErrEmptyPipelineWhereInput = errors.New("ent: empty predicate PipelineWhereInput")

// P returns a predicate for filtering pipelines.
// An error is returned if the input is empty or invalid.
func (i *PipelineWhereInput) P() (predicate.Pipeline, error) {
	var predicates []predicate.Pipeline
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, pipeline.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Pipeline, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, pipeline.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Pipeline, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, pipeline.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, pipeline.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, pipeline.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, pipeline.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, pipeline.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, pipeline.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, pipeline.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, pipeline.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, pipeline.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, pipeline.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, pipeline.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, pipeline.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, pipeline.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, pipeline.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, pipeline.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, pipeline.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, pipeline.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, pipeline.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, pipeline.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, pipeline.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, pipeline.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, pipeline.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, pipeline.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, pipeline.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, pipeline.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, pipeline.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, pipeline.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, pipeline.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, pipeline.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, pipeline.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, pipeline.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, pipeline.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, pipeline.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, pipeline.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, pipeline.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, pipeline.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, pipeline.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, pipeline.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasStages != nil {
		p := pipeline.HasStages()
		if !*i.HasStages {
			p = pipeline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStagesWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStagesWith))
		for _, w := range i.HasStagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pipeline.HasStagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPipelineWhereInput
	case 1:
		return predicates[0], nil
	default:
		return pipeline.And(predicates...), nil
	}
}

// QueueWhereInput represents a where input for filtering Queue queries.
type QueueWhereInput struct {
	Predicates []predicate.Queue  `json:"-"`
	Not        *QueueWhereInput   `json:"not,omitempty"`
	Or         []*QueueWhereInput `json:"or,omitempty"`
	And        []*QueueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type" field predicates.
	Type      *queue.Type  `json:"type,omitempty"`
	TypeNEQ   *queue.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []queue.Type `json:"typeIn,omitempty"`
	TypeNotIn []queue.Type `json:"typeNotIn,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "stages" edge predicates.
	HasStages     *bool              `json:"hasStages,omitempty"`
	HasStagesWith []*StageWhereInput `json:"hasStagesWith,omitempty"`

	// "employees" edge predicates.
	HasEmployees     *bool                 `json:"hasEmployees,omitempty"`
	HasEmployeesWith []*EmployeeWhereInput `json:"hasEmployeesWith,omitempty"`

	// "department" edge predicates.
	HasDepartment     *bool                   `json:"hasDepartment,omitempty"`
	HasDepartmentWith []*DepartmentWhereInput `json:"hasDepartmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *QueueWhereInput) AddPredicates(predicates ...predicate.Queue) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the QueueWhereInput filter on the QueueQuery builder.
func (i *QueueWhereInput) Filter(q *QueueQuery) (*QueueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyQueueWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyQueueWhereInput is returned in case the QueueWhereInput is empty.
var ErrEmptyQueueWhereInput = errors.New("ent: empty predicate QueueWhereInput")

// P returns a predicate for filtering queues.
// An error is returned if the input is empty or invalid.
func (i *QueueWhereInput) P() (predicate.Queue, error) {
	var predicates []predicate.Queue
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, queue.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Queue, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, queue.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Queue, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, queue.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, queue.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, queue.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, queue.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, queue.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, queue.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, queue.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, queue.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, queue.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, queue.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, queue.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, queue.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, queue.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, queue.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, queue.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, queue.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, queue.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, queue.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, queue.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, queue.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, queue.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, queue.NameContainsFold(*i.NameContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, queue.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, queue.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, queue.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, queue.TypeNotIn(i.TypeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, queue.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, queue.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, queue.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, queue.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, queue.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, queue.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, queue.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, queue.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, queue.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, queue.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, queue.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, queue.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, queue.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, queue.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, queue.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, queue.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasStages != nil {
		p := queue.HasStages()
		if !*i.HasStages {
			p = queue.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStagesWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStagesWith))
		for _, w := range i.HasStagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, queue.HasStagesWith(with...))
	}
	if i.HasEmployees != nil {
		p := queue.HasEmployees()
		if !*i.HasEmployees {
			p = queue.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmployeesWith) > 0 {
		with := make([]predicate.Employee, 0, len(i.HasEmployeesWith))
		for _, w := range i.HasEmployeesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmployeesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, queue.HasEmployeesWith(with...))
	}
	if i.HasDepartment != nil {
		p := queue.HasDepartment()
		if !*i.HasDepartment {
			p = queue.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDepartmentWith) > 0 {
		with := make([]predicate.Department, 0, len(i.HasDepartmentWith))
		for _, w := range i.HasDepartmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDepartmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, queue.HasDepartmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyQueueWhereInput
	case 1:
		return predicates[0], nil
	default:
		return queue.And(predicates...), nil
	}
}

// StageWhereInput represents a where input for filtering Stage queries.
type StageWhereInput struct {
	Predicates []predicate.Stage  `json:"-"`
	Not        *StageWhereInput   `json:"not,omitempty"`
	Or         []*StageWhereInput `json:"or,omitempty"`
	And        []*StageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "lossOrGain" field predicates.
	LossOrGain    *bool `json:"lossorgain,omitempty"`
	LossOrGainNEQ *bool `json:"lossorgainNEQ,omitempty"`

	// "createdAt" field predicates.
	CreatedAt      *time.Time  `json:"createdat,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdatNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdatIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdatNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdatGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdatGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdatLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdatLTE,omitempty"`

	// "updatedAt" field predicates.
	UpdatedAt      *time.Time  `json:"updatedat,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedatNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedatIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedatNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedatGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedatGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedatLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedatLTE,omitempty"`

	// "pipeline" edge predicates.
	HasPipeline     *bool                 `json:"hasPipeline,omitempty"`
	HasPipelineWith []*PipelineWhereInput `json:"hasPipelineWith,omitempty"`

	// "deals" edge predicates.
	HasDeals     *bool             `json:"hasDeals,omitempty"`
	HasDealsWith []*DealWhereInput `json:"hasDealsWith,omitempty"`

	// "queue" edge predicates.
	HasQueue     *bool              `json:"hasQueue,omitempty"`
	HasQueueWith []*QueueWhereInput `json:"hasQueueWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StageWhereInput) AddPredicates(predicates ...predicate.Stage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StageWhereInput filter on the StageQuery builder.
func (i *StageWhereInput) Filter(q *StageQuery) (*StageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStageWhereInput is returned in case the StageWhereInput is empty.
var ErrEmptyStageWhereInput = errors.New("ent: empty predicate StageWhereInput")

// P returns a predicate for filtering stages.
// An error is returned if the input is empty or invalid.
func (i *StageWhereInput) P() (predicate.Stage, error) {
	var predicates []predicate.Stage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, stage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Stage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, stage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Stage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, stage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, stage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, stage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, stage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, stage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, stage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, stage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, stage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, stage.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, stage.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, stage.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, stage.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, stage.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, stage.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, stage.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, stage.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, stage.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, stage.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, stage.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, stage.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, stage.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, stage.NameContainsFold(*i.NameContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, stage.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, stage.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, stage.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, stage.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, stage.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, stage.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, stage.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, stage.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, stage.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, stage.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, stage.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, stage.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, stage.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.LossOrGain != nil {
		predicates = append(predicates, stage.LossOrGainEQ(*i.LossOrGain))
	}
	if i.LossOrGainNEQ != nil {
		predicates = append(predicates, stage.LossOrGainNEQ(*i.LossOrGainNEQ))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, stage.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, stage.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, stage.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, stage.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, stage.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, stage.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, stage.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, stage.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, stage.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, stage.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, stage.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, stage.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, stage.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, stage.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, stage.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, stage.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasPipeline != nil {
		p := stage.HasPipeline()
		if !*i.HasPipeline {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPipelineWith) > 0 {
		with := make([]predicate.Pipeline, 0, len(i.HasPipelineWith))
		for _, w := range i.HasPipelineWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPipelineWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasPipelineWith(with...))
	}
	if i.HasDeals != nil {
		p := stage.HasDeals()
		if !*i.HasDeals {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDealsWith) > 0 {
		with := make([]predicate.Deal, 0, len(i.HasDealsWith))
		for _, w := range i.HasDealsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDealsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasDealsWith(with...))
	}
	if i.HasQueue != nil {
		p := stage.HasQueue()
		if !*i.HasQueue {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQueueWith) > 0 {
		with := make([]predicate.Queue, 0, len(i.HasQueueWith))
		for _, w := range i.HasQueueWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQueueWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasQueueWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return stage.And(predicates...), nil
	}
}

// TextWhereInput represents a where input for filtering Text queries.
type TextWhereInput struct {
	Predicates []predicate.Text  `json:"-"`
	Not        *TextWhereInput   `json:"not,omitempty"`
	Or         []*TextWhereInput `json:"or,omitempty"`
	And        []*TextWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "text" field predicates.
	Text             *string  `json:"text,omitempty"`
	TextNEQ          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGT           *string  `json:"textGT,omitempty"`
	TextGTE          *string  `json:"textGTE,omitempty"`
	TextLT           *string  `json:"textLT,omitempty"`
	TextLTE          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`

	// "message" edge predicates.
	HasMessage     *bool                `json:"hasMessage,omitempty"`
	HasMessageWith []*MessageWhereInput `json:"hasMessageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TextWhereInput) AddPredicates(predicates ...predicate.Text) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TextWhereInput filter on the TextQuery builder.
func (i *TextWhereInput) Filter(q *TextQuery) (*TextQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTextWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTextWhereInput is returned in case the TextWhereInput is empty.
var ErrEmptyTextWhereInput = errors.New("ent: empty predicate TextWhereInput")

// P returns a predicate for filtering texts.
// An error is returned if the input is empty or invalid.
func (i *TextWhereInput) P() (predicate.Text, error) {
	var predicates []predicate.Text
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, text.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Text, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, text.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Text, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, text.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, text.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, text.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, text.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, text.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, text.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, text.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, text.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, text.IDLTE(*i.IDLTE))
	}
	if i.Text != nil {
		predicates = append(predicates, text.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, text.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, text.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, text.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, text.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, text.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, text.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, text.TextLTE(*i.TextLTE))
	}
	if i.TextContains != nil {
		predicates = append(predicates, text.TextContains(*i.TextContains))
	}
	if i.TextHasPrefix != nil {
		predicates = append(predicates, text.TextHasPrefix(*i.TextHasPrefix))
	}
	if i.TextHasSuffix != nil {
		predicates = append(predicates, text.TextHasSuffix(*i.TextHasSuffix))
	}
	if i.TextEqualFold != nil {
		predicates = append(predicates, text.TextEqualFold(*i.TextEqualFold))
	}
	if i.TextContainsFold != nil {
		predicates = append(predicates, text.TextContainsFold(*i.TextContainsFold))
	}

	if i.HasMessage != nil {
		p := text.HasMessage()
		if !*i.HasMessage {
			p = text.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessageWith) > 0 {
		with := make([]predicate.Message, 0, len(i.HasMessageWith))
		for _, w := range i.HasMessageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMessageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, text.HasMessageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTextWhereInput
	case 1:
		return predicates[0], nil
	default:
		return text.And(predicates...), nil
	}
}
