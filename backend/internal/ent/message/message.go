// Code generated by ent, DO NOT EDIT.

package message

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

const (
	// Label holds the string label denoting the message type in the database.
	Label = "message"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldSentBy holds the string denoting the sentby field in the database.
	FieldSentBy = "sent_by"
	// FieldPrivate holds the string denoting the private field in the database.
	FieldPrivate = "private"
	// FieldType holds the string denoting the type field in the database.
	FieldType = "type"
	// FieldCreatedAt holds the string denoting the createdat field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updatedat field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeChat holds the string denoting the chat edge name in mutations.
	EdgeChat = "chat"
	// EdgeEmployee holds the string denoting the employee edge name in mutations.
	EdgeEmployee = "employee"
	// EdgeText holds the string denoting the text edge name in mutations.
	EdgeText = "text"
	// EdgeFile holds the string denoting the file edge name in mutations.
	EdgeFile = "file"
	// Table holds the table name of the message in the database.
	Table = "messages"
	// ChatTable is the table that holds the chat relation/edge.
	ChatTable = "messages"
	// ChatInverseTable is the table name for the Chat entity.
	// It exists in this package in order to avoid circular dependency with the "chat" package.
	ChatInverseTable = "chats"
	// ChatColumn is the table column denoting the chat relation/edge.
	ChatColumn = "message_chat"
	// EmployeeTable is the table that holds the employee relation/edge. The primary key declared below.
	EmployeeTable = "message_employee"
	// EmployeeInverseTable is the table name for the Employee entity.
	// It exists in this package in order to avoid circular dependency with the "employee" package.
	EmployeeInverseTable = "employees"
	// TextTable is the table that holds the text relation/edge.
	TextTable = "messages"
	// TextInverseTable is the table name for the Text entity.
	// It exists in this package in order to avoid circular dependency with the "text" package.
	TextInverseTable = "texts"
	// TextColumn is the table column denoting the text relation/edge.
	TextColumn = "text_message"
	// FileTable is the table that holds the file relation/edge.
	FileTable = "messages"
	// FileInverseTable is the table name for the File entity.
	// It exists in this package in order to avoid circular dependency with the "file" package.
	FileInverseTable = "files"
	// FileColumn is the table column denoting the file relation/edge.
	FileColumn = "file_message"
)

// Columns holds all SQL columns for message fields.
var Columns = []string{
	FieldID,
	FieldSentBy,
	FieldPrivate,
	FieldType,
	FieldCreatedAt,
	FieldUpdatedAt,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "messages"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"file_message",
	"message_chat",
	"text_message",
}

var (
	// EmployeePrimaryKey and EmployeeColumn2 are the table columns denoting the
	// primary key for the employee relation (M2M).
	EmployeePrimaryKey = []string{"message_id", "employee_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "createdAt" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updatedAt" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updatedAt" field.
	UpdateDefaultUpdatedAt func() time.Time
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() uuid.UUID
)

// SentBy defines the type for the "sentBy" enum field.
type SentBy string

// SentBy values.
const (
	SentByEmployee SentBy = "employee"
	SentByCostumer SentBy = "costumer"
)

func (sb SentBy) String() string {
	return string(sb)
}

// SentByValidator is a validator for the "sentBy" field enum values. It is called by the builders before save.
func SentByValidator(sb SentBy) error {
	switch sb {
	case SentByEmployee, SentByCostumer:
		return nil
	default:
		return fmt.Errorf("message: invalid enum value for sentBy field: %q", sb)
	}
}

// Type defines the type for the "type" enum field.
type Type string

// Type values.
const (
	TypeText  Type = "text"
	TypeAudio Type = "audio"
	TypeImage Type = "image"
	TypeFile  Type = "file"
)

func (_type Type) String() string {
	return string(_type)
}

// TypeValidator is a validator for the "type" field enum values. It is called by the builders before save.
func TypeValidator(_type Type) error {
	switch _type {
	case TypeText, TypeAudio, TypeImage, TypeFile:
		return nil
	default:
		return fmt.Errorf("message: invalid enum value for type field: %q", _type)
	}
}

// OrderOption defines the ordering options for the Message queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// BySentBy orders the results by the sentBy field.
func BySentBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSentBy, opts...).ToFunc()
}

// ByPrivate orders the results by the private field.
func ByPrivate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPrivate, opts...).ToFunc()
}

// ByType orders the results by the type field.
func ByType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldType, opts...).ToFunc()
}

// ByCreatedAt orders the results by the createdAt field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updatedAt field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByChatField orders the results by chat field.
func ByChatField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newChatStep(), sql.OrderByField(field, opts...))
	}
}

// ByEmployeeCount orders the results by employee count.
func ByEmployeeCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newEmployeeStep(), opts...)
	}
}

// ByEmployee orders the results by employee terms.
func ByEmployee(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEmployeeStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTextField orders the results by text field.
func ByTextField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTextStep(), sql.OrderByField(field, opts...))
	}
}

// ByFileField orders the results by file field.
func ByFileField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFileStep(), sql.OrderByField(field, opts...))
	}
}
func newChatStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ChatInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, ChatTable, ChatColumn),
	)
}
func newEmployeeStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EmployeeInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, EmployeeTable, EmployeePrimaryKey...),
	)
}
func newTextStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TextInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, true, TextTable, TextColumn),
	)
}
func newFileStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FileInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, true, FileTable, FileColumn),
	)
}

// MarshalGQL implements graphql.Marshaler interface.
func (e SentBy) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(e.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (e *SentBy) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*e = SentBy(str)
	if err := SentByValidator(*e); err != nil {
		return fmt.Errorf("%s is not a valid SentBy", str)
	}
	return nil
}

// MarshalGQL implements graphql.Marshaler interface.
func (e Type) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(e.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (e *Type) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("enum %T must be a string", val)
	}
	*e = Type(str)
	if err := TypeValidator(*e); err != nil {
		return fmt.Errorf("%s is not a valid Type", str)
	}
	return nil
}
